#!/bin/bash

set -e

[ -e /etc/vdr2avi.cfg ] && source /etc/vdr2avi.cfg
[ -e ~/.vdr2avi.cfg ] && source ~/.vdr2avi.cfg
[ -e vdr2avi.cfg ] && source vdr2avi.cfg

function syntax() {
cat <<ENDOFHELP
Syntax: [-pr recorded-path] [-pt <temp-path>] [-pv <vid-path>] <part> <video path/name> <quality> <encoder-arguments>...
part can be 0 => print an overview of all videos
	    1 => convert vdr files to mpeg file with correct timecodes
	    2 => create edl cut list and crop values from mpeg file
	    3 => convert mpeg file to avi file with given quality
	    4 => same as 1 but run noad before (usefull if vdr was stopped during its "after" section
video path is the name of a .rec subdirectory relative to $VID_PATH
	(only required for part 1)
video name is the name of a video
	(only required for part 2 and 3)
quality can be
	(only required for part 3)
	lowest, low, normal, high or highest
	   for misc quality/filesize ratios
	copy
	   for direct mpeg copying (ignores cropping)
encoder-arguments can be
	(only possible for part 3)
	nocrop     ignore crop values (always on for quality: copy)
	nocut      ignore edl cutlist (whole file will be processed)
	start=<s>  start encoding at position s (in secs or hh:mm:ss)
ENDOFHELP
}

function print_overview() {
	printf "  %-80s %s\n" "Video Path/Name" "Next Part"
	cd $VID_PATH
	for file in `find -type f -name "001.vdr" -printf "%P\n"`; do
		file=${file%/*}
		printf "P %-80s %d\n" "$file" 1
	done
	cd $TMP_PATH
	for file in *.rdy1; do
		if [ -e "$file" ]; then
			[[ "$file" =~ (.*).rdy1$ ]]
			path=${BASH_REMATCH[1]}
			if [ ! -e $path.rdy2 ]; then
				printf "N %-80s %d\n" "$path" 2
			fi
		fi
	done
	for file in *.rdy2; do
		if [ -e "$file" ]; then
			[[ "$file" =~ (.*).rdy2$ ]]
			path=${BASH_REMATCH[1]}
			printf "N %-80s %d\n" "$path" 3
		fi
	done
	cd $TRG_PATH
	for file in *.avi; do
		if [ -e "$file" ]; then
			[[ "$file" =~ (.*).avi$ ]]
			path=${BASH_REMATCH[1]}
			printf "N %-80s %s\n" "$path" R
		fi
	done
}

function conv_time_to_sec() {
	# hr:min:sec.hs text
	[[ "$1" =~ ^([0-9]*):([0-9]*):([0-9]*)\.([0-9]*)\ .* ]] || { echo "Error: Invalid time format in '$1'" >&2; exit 1; }
	echo $[ 10#${BASH_REMATCH[1]} * 3600 + 10#${BASH_REMATCH[2]} * 60 + 10#${BASH_REMATCH[3]} ]
}

# Use the logo start nearest to $1(REC_BUFFER_START) minutes in the marks file
function get_movie_start() {
	ms_delta="9999999"
	buf_st=$1
	while read -r line; do
		echo -e "\tChecking line `$line`" >&2
		if [[ "$line" =~ Logo\ start ]]; then
			ms=`conv_time_to_sec "$line"`
			if [ -z $ms ]; then
				echo "-1"
				return
			fi
			echo "Line has timecode $ms" >&2
			if [ $ms -gt $buf_st ]; then
				delta=$[ $ms - $buf_st ]
			else
				delta=$[ $buf_st - $ms ]
			fi
			if [ $ms_delta -gt $delta ]; then
				ms_delta=$delta
				ms_res=$ms
				echo "Found new possible value $ms_res (delta $ms_delta)" >&2
			fi
		fi
	done
	echo ${ms_res:--1}
}

# Use the last logo lost or IFrame mark in the marks file
function get_movie_end() {
	while read -r line; do
		echo -e "\tChecking line `$line`" >&2
		if [[ "$line" =~ (Logo\ lost|last\ IFrame) ]]; then
			ms=`conv_time_to_sec "$line"`
			echo "Line has timecode $ms" >&2
			if [ -z $ms ]; then
				echo "-1"
				return
			fi
		fi
	done
	echo ${ms:--1}
}

function get_movie_ads() {
	vid_start=$1
	vid_end=$2
	ad_start=""
	while read -r line; do
		echo -e "\tChecking line '$line'" >&2
		ms=`conv_time_to_sec "$line"`
		[ -z $ms ] && return 1
		echo "Line has timecode $ms, vid_start=$vid_start, vid_end=$vid_end" >&2
		if [ $ms -gt $vid_start -a $ms -lt $vid_end ]; then
			if [ "$ad_start" ]; then
				if [[ "$line" =~ Logo\ start ]]; then
					if [ $[ $ms - $ad_start ] -gt 900 ]; then
						echo "Error: Advertising sequences longer than 15 min !? $ad_start - $ms" >&2
					elif [ $[ $ms - $ad_start ] -lt 120 ]; then
						echo "Error: Advertising sequences smaller than 2 min !? $ad_start - $ms" >&2
					else
						ad_end=$[ $ms - 10#$CUT_OFFSET_ADS ]
						[ $ad_start -lt $ad_end ] && printf "%-6s %6s 0\n" $ad_start $ad_end
					fi
					ad_start=""
				else
					echo "Error: Bad Logo start/lost sequences in $ad_start - $ms" >&2
				fi
			else
				if [[ "$line" =~ Logo\ lost ]]; then
					ad_start=$[ $ms + 10#$CUT_OFFSET_ADS ]
				else
					echo "Error: Bad Logo start/lost sequences at $ms" 1>&2
				fi
			fi
		fi
	done
	[ "$ad_start" ] && echo "Error: Missing end of advertising after position $ad_start" >&2
}

function get_most_used() {
	declare -a va
	declare -a ca
	cnt=0
	
	for v in $*; do
		echo -e "value: $v"
		found=false
		for (( i = 0 ; $i < ${#va[@]} ; i++ )); do
			if [ ${va[$i]} = $v ]; then
				found=true
				ca[$i]=$[ 10#${ca[$i]} + 1 ]
				break
			fi
		done
		if ! $found; then
			va[$cnt]=$v
			ca[$cnt]=1
			cnt=$[ $cnt + 1 ]
		fi
	done
	
	maxc=0
	maxv=0
	for (( i = 0 ; $i < ${#va[@]} ; i++ )); do
		printf "%2dx %5dpx\n" ${ca[$i]} ${va[$i]}
		if [ $maxc -lt ${ca[$i]} ]; then
			maxc=${ca[$i]}
			maxv=${va[$i]}
		fi
	done
	
	printf "Using %dpx\n" $maxv
}

function run_noad() {
	rm -f "$VID_PATH/$VID_DIR/noad.pid"
	rm -f "$VID_PATH/$VID_DIR/marks.vdr"
	
	noad $NOAD_ARGS "$VID_DIR"
}

function create_mpeg() {
	rec_path=$VID_PATH/$VID_DIR
	rm -f "$TMP_PATH/$VID_NAME.rdy1"
	
	# Wait for noad to finish parsing the vdr source files
	sleep 5
	while [ -e "$rec_path/noad.pid" ] && ps `cat "$rec_path/noad.pid"` >/dev/null; do
		sleep 10
	done
	 
	echo "`date`: Processing $VID_NAME" >&2

	srcsize=0
	for file in $rec_path/[0-9][0-9][0-9].vdr; do
		[ -r "$file" ] && srcsize=$[ 10#$srcsize + 10#`stat -c %s "$file"` ]
	done
	
	if [ -e "$TMP_PATH/$VID_NAME.mpg" ]; then
		echo "$TMP_PATH/$VID_NAME.mpg already exists! Skipping timecode correction"
	else
		free=$[ 10#`stat -fc %a "$TMP_PATH"` * 10#`stat -fc %S "$TMP_PATH"` ]
		if [ $free -lt $srcsize ]; then
			echo "Less than $[ 10#$srcsize / 1024 / 1024 ] MB free on target device for new mpeg file! Exiting"
			exit 1
		fi
		
		echo "Correcting timecodes of $VID_NAME"
		cat $rec_path/[0-9][0-9][0-9].vdr | \
			$NICE_MENCODER mencoder -quiet -cache 32768 \
			-oac copy -ovc copy -of mpeg \
			-o "$TMP_PATH/$VID_NAME.mpg" - 2>/dev/null
		chmod 666 "$TMP_PATH/$VID_NAME.mpg"
	fi
	
	if [ ! -e "$TMP_PATH/$VID_NAME.mpg" ]; then
		echo "Target file does not exist! Exiting"
		exit 1
	fi
	trgsize=`stat -c %s "$TMP_PATH/$VID_NAME.mpg"`
	[ $srcsize = 0 ] && perc=100 || perc=$[ 10#$trgsize * 100 / 10#$srcsize ]
	if [ $perc -lt 80 ]; then
		echo "Target file is very small (only $perc% of source files)! Exiting"
		exit 1
	fi
	
	free=$[ 10#`stat -fc %a "$TMP_PATH/$VID_NAME.mpg"` * 10#`stat -fc %S "$TMP_PATH/$VID_NAME.mpg"` ]
	if [ $free -lt 33554432 ]; then
		echo "Less than 32 MB free on target device after mpeg creation! Exiting"
		exit 1
	fi
	
	rm -f $rec_path/0[0-9][0-9].vdr
	
	echo "Detecting correct cropping values for $VID_NAME"
	
	# Check every 3 minutes of the video for black borders with default tresh
	cd_w=""
	cd_h=""
	for (( timepos=1; $timepos < 1000; timepos++ )); do
		cd_res=`$NICE_MENCODER mplayer "$TMP_PATH/$VID_NAME.mpg" -vo null -ao null \
			-vf cropdetect=24:16 -ss $[ $timepos * 180 ] -frames 5 -nozoom -quiet \
			| grep "\[CROP\]" | tail -n 1`
		[[ "$cd_res" =~ crop=([0-9]*):([0-9]*) ]] || break
		cd_w="$cd_w ${BASH_REMATCH[1]}"
		cd_h="$cd_h ${BASH_REMATCH[2]}"
	done
	echo "Detected width of video:"
	get_most_used $cd_w
	cropw=$maxv
	echo "Detected height of video:"
	get_most_used $cd_h
	croph=$maxv
	if [ $cropw -ge 600 -a $cropw -le $MPG_WIDTH -a $croph -ge 200 -a $croph -le $MPG_HEIGHT ]; then
		echo "Final crop string: $cropw:$croph" 
		echo "$cropw:$croph" > "$TMP_PATH/$VID_NAME.crop"
		chmod 666 "$TMP_PATH/$VID_NAME.crop"
	else
		echo "Final crop string: $cropw:$croph => Out of bounds - don't using any crop" 
		rm -f "$TMP_PATH/$VID_NAME.crop"
	fi
	
	if [ -e "$rec_path/marks.vdr" ]; then
		buf_st=$REC_BUFFER_START
		for (( i = 0; $i < ${#REC_BUFFER_START_NAME[@]}; i++ )); do
			[[ "$VID_NAME" =~ "${REC_BUFFER_START_NAME[$i]}" ]] && buf_st=${REC_BUFFER_START_VALUE[$i]}
		done
		start=`get_movie_start $buf_st < "$rec_path/marks.vdr"`
		
		if [ "$start" = "-1" ]; then
			echo "Error: Cannot detect movie start in marks.vdr" >&2
			exit 1
		fi
		
		end=`get_movie_end < "$rec_path/marks.vdr"`
		
		if [ "$end" = "-1" ]; then
			echo "Error: Cannot detect movie end in marks.vdr" >&2
			exit 1
		fi
		
		if [ $start -ge $end ]; then
			echo "Error: Start of movie is beyond end in marks.vdr" >&2
			exit 1
		fi
		
		start_off=$[ $start - 10#$CUT_OFFSET_ADS - 10#$CUT_OFFSET_START ]
		[ $start_off -lt 0 ] && start_off=0
		printf "%-6s %6s 0\n" 0000 $start_off > "$TMP_PATH/$VID_NAME.edl"
		
		get_movie_ads $start $end < "$rec_path/marks.vdr" >> "$TMP_PATH/$VID_NAME.edl"
		
		end_off=$[ $end + 10#$CUT_OFFSET_ADS + 10#$CUT_OFFSET_END ]
		printf "%-6s %6s 0\n" $end_off 999999 >> "$TMP_PATH/$VID_NAME.edl"
		
		echo "Created cutlist:"
		cat "$TMP_PATH/$VID_NAME.edl"
		chmod 666 "$TMP_PATH/$VID_NAME.edl"
	else
		echo "No marks.vdr found. Skipping cutlist creation."
	fi
	
	touch "$TMP_PATH/$VID_NAME.rdy1"
	chmod 666 "$TMP_PATH/$VID_NAME.rdy1"
}

function create_screenshot() {
	echo "Creating screenshot for position $1 ..." >&2
	cnt=`ls $2 | wc -l`
	echo "seek $1 2"
	echo "screenshot 0"
	while [ `ls $2 | wc -l` = $cnt ]; do
		if [ -z "`pgrep -lP $$ | grep mplayer`" ]; then
			# Seeked after eof or an error occurred in mplayer
			echo "MPlayer no longer running." >&2
			return
		fi
		sleep 0.2
	done
	# Recently modified image file
	sleep 0.3
	png=`ls -rt $2 | tail -1`
	echo "Modifying $png ..." 1>&2
	msg=`printf "%s @ %02d:%02d" "$3" $[ $1 / 60 ] $[ $1 % 60 ]`
	jpg=`printf "%02d %s.jpg" $cnt "$msg"`
	convert $png \
		-pointsize 36 -stroke yellow \
		-draw "text 20,100 '$msg'" \
		-quality 30 "$jpg"
	rm -f $png
}

function play_video() {
	$use_edl && [ -e "$TMP_PATH/$VID_NAME.edl" ] && \
		edl_cmd="-edl $TMP_PATH/$VID_NAME.edl" || edl_cmd=""
	
	mplayer $TMP_PATH/$VID_NAME.mpg -quiet \
		$edl_cmd -edlout $TMP_PATH/$VID_NAME.edl.new \
		-vf-add crop=`cat $TMP_PATH/$VID_NAME.crop` -vf-add pp=lb
		
	# set the first edl value in the first line to 0, and the last one in the last line to 99999
	v=`head -n 1 "$TMP_PATH/$VID_NAME.edl.new"`
	[[ "$v" =~ ^([0-9]*)\.([0-9]*)\ *([0-9]*)\.([0-9]*)\ ([0-9])$ ]]
	vstart=${BASH_REMATCH[1]}
	[ "$vstart" -a 10#$vstart -le 5 ] && \
		sed -i "s/^${BASH_REMATCH[1]}\.${BASH_REMATCH[2]} /0000.0000 /" "$TMP_PATH/$VID_NAME.edl.new"
	v=`tail -n 1 "$TMP_PATH/$VID_NAME.edl.new"`
	[[ "$v" =~ ^([0-9]*)\.([0-9]*)\ *([0-9]*)\.([0-9]*)\ ([0-9])$ ]]
	vstart=${BASH_REMATCH[1]}
	vend=${BASH_REMATCH[3]}
	[ "$vstart" -a "$vend" -a $[ $end - $vstart ] -le 5 ] && \
		sed -i "s/ ${BASH_REMATCH[3]}\.${BASH_REMATCH[4]} / 999999.9999 /" "$TMP_PATH/$VID_NAME.edl.new"
}

function user_edit_mpeg() {
	rm -f "$TMP_PATH/$VID_NAME.rdy2"
	[ -e "$TMP_PATH/$VID_NAME.crop" ] || touch "$TMP_PATH/$VID_NAME.crop"
	use_edl=false
	while true; do
		echo "Current Cutlist:"
		[ -e "$TMP_PATH/$VID_NAME.edl" ] && cat "$TMP_PATH/$VID_NAME.edl" || echo "<Empty>"
		echo "New Cutlist:"
		[ -e "$TMP_PATH/$VID_NAME.edl.new" ] && cat "$TMP_PATH/$VID_NAME.edl.new" || echo "<Empty>"
		echo "Croplist:"
		cat "$TMP_PATH/$VID_NAME.crop"
		echo
		
		echo -ne "[A]ccept, [P]lay video again, Play [V]ideo" \
			`$use_edl && echo "without" || echo "with"` "EDL cutlist," \
			"Create Screensh[O]ts,\n" \
			"[U]se new cutlist, [M]erge current and new one, [R]eject new one, [E]dit cutlist,\n" \
			"[I]ncrement or [D]ecrement crop height by 16 ([W], [S] for width), [N]o crop or [C]ancel? "
		read asw
		case $asw in
			"a" | "A" )
				echo "Accepted cut list and crop values. Ready for part 3."
				touch "$TMP_PATH/$VID_NAME.rdy2"
				chmod 666 "$TMP_PATH/$VID_NAME.rdy2"
				return;;
			"p" | "P" )
				play_video;;
			"v" | "V" )
				$use_edl && use_edl=false || use_edl=true
				play_video;;
			"e" | "e" )
				$EDITOR "$TMP_PATH/$VID_NAME.edl";;
			"u" | "U" )
				mv -f "$TMP_PATH/$VID_NAME.edl.new" "$TMP_PATH/$VID_NAME.edl"
				echo "New Cutlist is now the current one.";;
			"m" | "M" )
				cat "$TMP_PATH/$VID_NAME.edl.new" >> "$TMP_PATH/$VID_NAME.edl"
				rm -f "$TMP_PATH/$VID_NAME.edl.new"
				echo "New Cutlist added to current one.";;
			"n" | "N" )
				echo -n "$MPG_WIDTH:$MPG_HEIGHT" > "$TMP_PATH/$VID_NAME.crop"
				echo "Crop reset to $MPG_WIDTH:$MPG_HEIGHT";;
			"r" | "R" )
				rm -f "$TMP_PATH/$VID_NAME.edl.new"
				echo "New Cutlist deleted";;
			"i" | "I" )
				[[ `cat "$TMP_PATH/$VID_NAME.crop"` =~ ^([0-9]*):([0-9]*)$ ]]
				echo -n "${BASH_REMATCH[1]}:$[ ${BASH_REMATCH[2]} + 16 ]" > "$TMP_PATH/$VID_NAME.crop";;
			"d" | "D" )
				[[ `cat "$TMP_PATH/$VID_NAME.crop"` =~ ^([0-9]*):([0-9]*)$ ]]
				echo -n "${BASH_REMATCH[1]}:$[ ${BASH_REMATCH[2]} - 16 ]" > "$TMP_PATH/$VID_NAME.crop";;
			"w" | "W" )
				[[ `cat "$TMP_PATH/$VID_NAME.crop"` =~ ^([0-9]*):([0-9]*)$ ]]
				echo -n "$[ ${BASH_REMATCH[1]} + 16 ]:${BASH_REMATCH[2]}" > "$TMP_PATH/$VID_NAME.crop";;
			"s" | "S" )
				[[ `cat "$TMP_PATH/$VID_NAME.crop"` =~ ^([0-9]*):([0-9]*)$ ]]
				echo -n "$[ ${BASH_REMATCH[1]} - 16 ]:${BASH_REMATCH[2]}" > "$TMP_PATH/$VID_NAME.crop";;
			"c" | "C" )
				echo "Cancelled"
				echo "Video stays in part 2"
				return;;
			"o" | "O" )
				tmpdir=`mktemp -d -t vdrscr.XXXXXX`
				cd $tmpdir
				(
					sleep 2
					while read -r start end type; do
						if [ $start -gt 0 ]; then
							create_screenshot $[ $start - 5 ] $tmpdir "Before ad start"
							create_screenshot $start $tmpdir "Ad start"
							create_screenshot $[ $start + 5 ] $tmpdir "After ad start"
							if [ $end -eq 999999 ]; then
								echo "quit"
								break
							fi
							create_screenshot $[ $start + ( $end - $start ) / 2] $tmpdir "Middle of Ad"
						fi
						create_screenshot $[ $end - 30 ] $tmpdir "Before ad end"
						create_screenshot $end $tmpdir "Ad end"
						create_screenshot $[ $end + 30 ] $tmpdir "After ad end"
						
					done < "$TMP_PATH/$VID_NAME.edl"
				) | mplayer -slave -vo null -nozoom \
						-vf-add crop=`cat "$TMP_PATH/$VID_NAME.crop"` \
						-vf-add pp=lb -vf-add screenshot\
						-really-quiet "$TMP_PATH/$VID_NAME.mpg"
				cd "$OLDPWD"
				xv $tmpdir/[0-9][0-9]*.jpg
				rm -f $tmpdir/[0-9][0-9]*.jpg
				rmdir $tmpdir;;
			* )
				echo "Unknown answer";;
		esac
	done
}

function create_avi() {
	# Set additional arguments
	a_nocrop=false
	a_nocut=false
	a_start=""
	while [ "$1" ]; do
		case "$1" in
			"nocrop" )
				a_nocrop=true;;
			"nocut" )
				a_nocut=true;;
			*)
				[[ "$1" =~ ^start=(.*)$ ]] && a_start="-ss ${BASH_REMATCH[1]}";;
		esac
		shift
	done
	
	edlstr=""
	if [ -e "$TMP_PATH/$VID_NAME.edl" -a ! $a_nocut ]; then
		edlstr="-edl $TMP_PATH/$VID_NAME.edl"
	fi
	
	cropstr=""
	if [ -e "$TMP_PATH/$VID_NAME.crop" -a ! $a_nocrop ]; then
		[[ `cat "$TMP_PATH/$VID_NAME.crop"` =~ ^([0-9]*):([0-9]*)$ ]]
		cropw=${BASH_REMATCH[1]}
		croph=${BASH_REMATCH[2]}
		[ "$cropw" -a "$croph" ] && [ 10#$cropw -lt 10#$MPG_WIDTH -o 10#$croph -lt 10#$MPG_HEIGHT ] && \
			cropstr="-vf-add crop=$cropw:$croph"
	fi
	
	case "$qual" in
		"highest")
			audio=160
			video=1000
			width=$MPG_WIDTH;;
		"high")
			audio=128
			video=700
			width=648;;
		"normal")
			audio=96
			video=500
			width=576;;
		"low")
			audio=56
			video=350
			width=384;;
		"lowest")
			audio=32
			video=300
			width=288;;
		"copy")
			echo "Recoding to $VID_NAME_$qual.mpg with copy"
			cmd="$NICE_MENCODER mencoder -quiet -cache 32768 -nozoom \
				$edlstr -oac copy -ovc copy -audio-delay -0.3 -of mpeg $a_start \
				-o $TRG_PATH/${VID_NAME}_$qual.mpg $TMP_PATH/$VID_NAME.mpg"
			echo $cmd
			$cmd
			return;;
		*)
			echo "Unknown quality name: $qual"
			exit 1;;
	esac
	touch "$TRG_PATH/${VID_NAME}_$qual.avi"
	
	echo "Recoding to ${VID_NAME}_$qual.avi with $MENCODER_VIDEO_CODEC (width $width px, abr $video kbps) and mp3lame (abr $audio kbps)"
	avitmpdir=`mktemp -d`
	cd $avitmpdir
	cmd="$NICE_MENCODER mencoder \
		$edlstr -quiet \
		-oac mp3lame -lameopts abr:br=$audio -audio-delay -0.3 \
		-ovc $MENCODER_VIDEO_CODEC -${MENCODER_VIDEO_CODEC}encopts pass=1:bitrate=$video:$MENCODER_VIDEO_OPTS_PASS1 \
		$cropstr $a_start \
		`[ $MENCODER_DEINT ] && echo "-vf-add $MENCODER_DEINT"` \
		`[ $width -lt 10#$MPG_WIDTH ] && echo " -sws $MENCODER_SWSCALER -vf-add scale=$width:-3 "` \
		-o /dev/null $TMP_PATH/$VID_NAME.mpg"
	echo $cmd
	$cmd
	cmd="$NICE_MENCODER mencoder \
		$edlstr -quiet \
		-oac mp3lame -lameopts abr:br=$audio -audio-delay -0.3 \
		-ovc $MENCODER_VIDEO_CODEC -${MENCODER_VIDEO_CODEC}encopts pass=2:bitrate=$video:$MENCODER_VIDEO_OPTS_PASS2 \
		$cropstr $a_start \
		`[ $MENCODER_DEINT ] && echo "-vf-add $MENCODER_DEINT"` \
		`[ $width -lt 10#$MPG_WIDTH ] && echo " -sws $MENCODER_SWSCALER -vf-add scale=$width:-3 "` \
		-o $TRG_PATH/${VID_NAME}_$qual.avi $TMP_PATH/$VID_NAME.mpg"
	echo $cmd
	$cmd
	cd $OLDPWD
	rm $avitmpdir/divx2pass.log
	rmdir $avitmpdir
}

function check() {
	if [ ! -d "$TRG_PATH" ]; then
		echo "No such directory: $TRG_PATH"
		echo "Check config file"
		exit 1
	fi
	
	if [ ! -d "$TMP_PATH" ]; then
		echo "No such directory: $TMP_PATH"
		echo "Check config file"
		exit 1
	fi
	
	if [ ! -d "$VID_PATH" ]; then
		echo "No such directory: $VID_PATH"
		echo "Check config file"
		exit 1
	fi
}

function init_viddir() {
	# Make $VID_DIR relative to $VID_PATH if absolute
	[[ "$1" =~ ^$VID_PATH/(.*) ]] && VID_DIR="${BASH_REMATCH[1]}" || VID_DIR="$1"

	[[ "$VID_DIR" =~ ^(.*)\.[0-9][0-9]\.[0-9][0-9]\.rec$ ]] && VID_DIR="${BASH_REMATCH[1]}" # remove vdr priority
	VID_DIR=${VID_DIR//\//-} # subst all / with -
	VID_DIR=${VID_DIR//[^a-zA-Z0-9._-]/_} # subst all special characters with _
	
	if [ -z "$VID_NAME" -o -z "$VID_DIR" ]; then
		echo "Path of video is missing or incorrect: '$VID_DIR' '$VID_NAME'"
		exit 1
	fi
	
	if [ ! -d "$VID_PATH/$VID_DIR" ]; then
		echo "Path of video doesn\`t exist: '$VID_PATH/$VID_DIR'"
		exit 1
	fi
}

function init_vidname() {
	# Dont set a video directory
	VID_DIR=""

	# Use the whole string as video name
	VID_NAME="$1"

	if [ "$VID_NAME" != "${VID_NAME//\/}" ]; then
		echo "Name of video is incorrect: '$VID_NAME'"
		exit 1
	fi
	
	if [ -z "$VID_NAME" ]; then
		echo "Name of video is missing or incorrect: '$VID_NAME'"
		exit 1
	fi

	if [ ! -e "$TMP_PATH/$VID_NAME.mpg" ]; then
		echo "MPEG version of video doesn\`t exist: '$TMP_PATH/$VID_NAME.mpg'"
		exit 1
	fi
}

while [ "$1" ]; do
	case "$1" in
		"-pr" )
			TRG_PATH="$2"
			shift;;
		"-pt" )
			TMP_PATH="$2"
			shift;;
		"-pv" )
			VID_PATH="$3"
			shift;;
		"0")
			check
			print_overview
			exit 0;;
		"1")
			check
			init_viddir $2
			shift 2
			create_mpeg $*
			exit 0;;
		"2")
			check
			init_vidname $2
			shift 2
			user_edit_mpeg $*
			exit 0;;
		"3")
			check
			init_vidname $2
			qual="$3"
			if [ -z "$qual" ]; then
				echo "Quality setting missing"
				exit 1
			fi
			shift 3
			create_avi $*
			exit 0;;
		"4")
			check
			init_viddir $2
			shift 2
			run_noad $*
			create_mpeg $*
			exit 0;;
		"-h")
			syntax
			exit 1;;
		*)
			echo "Unknown part number or parameter: $1 -- use -h for help"
			exit 1;;
	esac
	shift
done
echo "No part number given -- use -h for help"
