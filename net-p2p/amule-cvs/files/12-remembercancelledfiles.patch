--- src.org/amule-remote-gui.h
+++ src/amule-remote-gui.h
@@ -578,6 +578,11 @@ public:
 		return m_shared_files->GetByID(id); 
 	}
 
+	bool FindCancelledFileByID(const CMD4Hash& id)
+	{
+		return false; //TODO access to CKnownFileList
+	}
+
 	uint16 requested;
 	uint32 transferred;
 	uint16 accepted;
--- src.org/DownloadQueue.cpp
+++ src/DownloadQueue.cpp
@@ -1403,7 +1403,7 @@ void CDownloadQueue::SetCatStatus(uint8 
 		
 	for ( ; it != files.end(); it++ ) {
 		switch ( newstatus ) {
-			case MP_CANCEL:	(*it)->Delete(); 	break;
+			case MP_CANCEL:	(*it)->Delete(true); 	break;
 			case MP_PAUSE:	(*it)->PauseFile();	break;
 			case MP_STOP:	(*it)->StopFile();	break;
 			case MP_RESUME:	(*it)->ResumeFile();	break;
--- src.org/ExternalConn.cpp
+++ src/ExternalConn.cpp
@@ -618,7 +618,7 @@ CECPacket *Get_EC_Response_PartFile_Cmd(
 				if ( thePrefs::StartNextFile() && (pfile->GetStatus() != PS_PAUSED) ) {
 					theApp->downloadqueue->StartNextFile(pfile);
 				}
-				pfile->Delete();
+				pfile->Delete(true);
 				break;
 
 			case EC_OP_PARTFILE_REHASH:
--- src.org/GuiEvents.cpp
+++ src/GuiEvents.cpp
@@ -610,7 +610,7 @@ namespace MuleNotify
 	
 	void PartFile_Delete(CPartFile* file)
 	{
-		file->Delete();
+		file->Delete(true);
 	}
 	
 	void PartFile_Rehash(CPartFile* file)
--- src.org/KnownFile.cpp
+++ src/KnownFile.cpp
@@ -642,6 +642,17 @@ bool CKnownFile::LoadFromFile(const CFil
 }
 
 
+bool CKnownFile::LoadFromCancelledMet(const CFileDataIO* file)
+{
+	m_abyFileHash = file->ReadHash();
+	uint8 tagcount = file->ReadUInt8();
+	// for compatibility with future versions which may add more data than just the hash
+	for (uint32 i = 0; i < tagcount; ++i)
+		CTag newtag(*file, false);
+	return true;
+}
+
+
 bool CKnownFile::WriteToFile(CFileDataIO* file)
 {
 	wxCHECK(!IsPartFile(), false);
--- src.org/KnownFile.h
+++ src/KnownFile.h
@@ -301,6 +301,8 @@ public:
 	static void CreateHashFromHashlist(const ArrayOfCMD4Hash& hashes, CMD4Hash* Output);
 	
 	void	ClearPriority();
+
+	bool LoadFromCancelledMet(const CFileDataIO* file);
 	
 	time_t	m_lastDateChanged;
 
--- src.org/KnownFileList.cpp
+++ src/KnownFileList.cpp
@@ -66,9 +66,17 @@ CKnownFileList::~CKnownFileList()
 
 bool CKnownFileList::Init()
 {
+	const bool resK = Init0(true);
+	const bool resC = Init0(false);
+	return resK && resC;
+}
+
+bool CKnownFileList::Init0(bool knownMet)
+{
+	wxString name = knownMet ? wxT("known") : wxT("cancelled");
 	CFile file;
 	
-	CPath fullpath = CPath(theApp->ConfigDir + wxT("known.met"));
+	CPath fullpath = CPath(theApp->ConfigDir + name + wxT(".met"));
 	if (!fullpath.FileExists()) {
 		// This is perfectly normal. The file was probably either
 		// deleted, or this is the first time running aMule.
@@ -76,40 +84,40 @@ bool CKnownFileList::Init()
 	}
 
 	if (!file.Open(fullpath)) {
-		AddLogLineM(true, _("Warning: known.met cannot be opened."));
+		AddLogLineM(true, _("Warning: ") + name + _(".met cannot be opened."));
 		return false;
 	}
 	
 	try {
 		uint8 version = file.ReadUInt8();
 		if ((version != MET_HEADER) && (version != MET_HEADER_WITH_LARGEFILES)) {
-			AddLogLineM(true, _("Warning: Knownfile list corrupted, contains invalid header."));
+			AddLogLineM(true, _("Warning: ") + name + _("file list corrupted, contains invalid header."));
 			return false;
 		}
 		
 		wxMutexLocker sLock(list_mut);
 		uint32 RecordsNumber = file.ReadUInt32();
 		AddDebugLogLineM(false, logKnownFiles,
-			wxString::Format(wxT("Reading %i known files from file format 0x%2.2x."),
-			RecordsNumber, version));
+			wxString::Format(wxT("Reading %i %ls files from file format 0x%2.2x."),
+			RecordsNumber, name.c_str(), version));
 		for (uint32 i = 0; i < RecordsNumber; i++) {
 			std::auto_ptr<CKnownFile> record(new CKnownFile());
-			if (record->LoadFromFile(&file)) {
+			if (knownMet ? record->LoadFromFile(&file) : record->LoadFromCancelledMet(&file)) {
 				AddDebugLogLineM(false, logKnownFiles,
-					CFormat(wxT("Known file read: %s")) % record->GetFileName());
-				Append(record.release());
+					CFormat(name + wxT(" file read: %s")) % record->GetFileName());
+				if (knownMet) AppendK(record.release()); else AppendC(record.release());
 			} else {
 				AddLogLineM(true,
-					wxT("Failed to load entry in knownfilelist, file may be corrupt"));
+					wxT("Failed to load entry in ") + name + wxT("filelist, file may be corrupt"));
 			}
 		}
-		AddDebugLogLineM(false, logKnownFiles, wxT("Finished reading known files"));
+		AddDebugLogLineM(false, logKnownFiles, wxT("Finished reading ") + name + wxT(" files"));
 	
 		return true;
 	} catch (const CInvalidPacket& e) {
-		AddLogLineM(true, wxT("Invalid entry in knownfilelist, file may be corrupt: ") + e.what());
+		AddLogLineM(true, wxT("Invalid entry in ") + name + wxT("filelist, file may be corrupt: ") + e.what());
 	} catch (const CSafeIOException& e) {
-		AddLogLineM(true, CFormat(_("IO error while reading known.met file: %s")) % e.what());
+		AddLogLineM(true, CFormat(_("IO error while reading ") + name + _(".met file: %s")) % e.what());
 	}	
 	
 	return false;
@@ -118,6 +126,12 @@ bool CKnownFileList::Init()
 
 void CKnownFileList::Save()
 {
+	SaveK();
+	SaveC();
+}
+
+void CKnownFileList::SaveK()
+{
 	CFile file(theApp->ConfigDir + wxT("known.met"), CFile::write);
 	if (!file.IsOpened()) {
 		return;
@@ -160,6 +174,32 @@ void CKnownFileList::Save()
 }
 
 
+void CKnownFileList::SaveC()
+{
+	CFile file(theApp->ConfigDir + wxT("cancelled.met"), CFile::write);
+	if (!file.IsOpened()) {
+		return;
+	}
+
+	wxMutexLocker sLock(list_mut);
+
+	try {
+		file.WriteUInt8(MET_HEADER);
+		
+		file.WriteUInt32(m_map_cld.size());
+
+		CancelledFileMap::iterator it = m_map_cld.begin();
+		for (; it != m_map_cld.end(); ++it) {
+			file.WriteHash(it->first);
+			file.WriteUInt8(0);
+		}
+		
+	} catch (const CIOFailureException& e) {
+		AddLogLineM(true, CFormat(_("Error while saving cancelled.met file: %s")) % e.what());
+	}
+}
+
+
 void CKnownFileList::Clear()
 {	
 	wxMutexLocker sLock(list_mut);
@@ -169,6 +209,7 @@ void CKnownFileList::Clear()
 		delete it->second;
 	}
 	m_knownFileMap.clear();
+	m_map_cld.clear();
 
 	for (KnownFileList::iterator it = m_duplicateFileList.begin();
 	     it != m_duplicateFileList.end(); ++it) {
@@ -251,15 +292,25 @@ CKnownFile* CKnownFileList::FindKnownFil
 
 }
 
+bool CKnownFileList::FindCancelledFileByID(const CMD4Hash& hash)
+{
+	wxMutexLocker sLock(list_mut);
+	return !hash.IsEmpty() && (m_map_cld.find(hash) != m_map_cld.end());
+}
 
 bool CKnownFileList::SafeAddKFile(CKnownFile* toadd)
 {
 	wxMutexLocker sLock(list_mut);
-	return Append(toadd);
+	return AppendK(toadd);
 }
 
+bool CKnownFileList::SafeAddCancelledFile(CKnownFile* toadd)
+{
+	wxMutexLocker sLock(list_mut);
+	return AppendC(toadd);
+}
 
-bool CKnownFileList::Append(CKnownFile *Record)
+bool CKnownFileList::AppendK(CKnownFile *Record)
 {
 	if (Record->GetFileSize() > 0) {
 		const CMD4Hash& tkey = Record->GetFileHash();
@@ -297,4 +348,16 @@ bool CKnownFileList::Append(CKnownFile *
 	}
 }
 
+bool CKnownFileList::AppendC(CKnownFile* Record)
+{
+	const CMD4Hash& tkey = Record->GetFileHash();
+	CancelledFileMap::iterator it = m_map_cld.find(tkey);
+	if ( it == m_map_cld.end() ) {
+		m_map_cld[tkey] = 1;
+		return true;
+	}
+	// The file is already on the list, ignore it.
+	return false;
+}
+
 // File_checked_for_headers
--- src.org/KnownFileList.h
+++ src/KnownFileList.h
@@ -49,6 +49,9 @@ public:
 	CKnownFile* FindKnownFileByID(const CMD4Hash& hash);
 	bool	IsKnownFile(const CKnownFile* file);
 
+	bool	SafeAddCancelledFile(CKnownFile* toadd);
+	bool	FindCancelledFileByID(const CMD4Hash& hash);
+	
 	uint16 requested;
 	uint32 transferred;
 	uint16 accepted;
@@ -56,7 +59,13 @@ public:
 private:
 	wxMutex	list_mut;
 
-	bool	Append(CKnownFile*);
+	bool	AppendK(CKnownFile*);
+	bool	AppendC(CKnownFile*);
+	bool 	Init0(bool knownMet);
+	void	SaveK();
+	void	SaveC();
+	typedef std::map<CMD4Hash, uint8> CancelledFileMap;
+	CancelledFileMap	m_map_cld;
 
 	CKnownFile *IsOnDuplicates(
 		const CPath& filename,
--- src.org/PartFileConvert.cpp
+++ src/PartFileConvert.cpp
@@ -391,7 +391,7 @@ int CPartFileConvert::performConvertToeM
 			AddDebugLogLineM(true, logPfConvert, wxT("IO error while converting partfiles: ") + e.what());
 			
 			delete[] ba;
-			file->Delete();
+			file->Delete(false);
 			return CONV_IOERROR;
 		}
 		
@@ -436,7 +436,7 @@ int CPartFileConvert::performConvertToeM
 			ret = CPath::CloneFile(oldfile, newfilename, false);
 		}
 		if (!ret) {
-			file->Delete();
+			file->Delete(false);
 			//delete file;
 			return CONV_FAILED;
 		}
@@ -458,7 +458,7 @@ int CPartFileConvert::performConvertToeM
 
 	if (!file->LoadPartFile(thePrefs::GetTempDir(), file->GetPartMetFileName(), false)) {
 		//delete file;
-		file->Delete();
+		file->Delete(false);
 		return CONV_BADFORMAT;
 	}
 
--- src.org/PartFile.cpp
+++ src/PartFile.cpp
@@ -2366,7 +2366,7 @@ void  CPartFile::RemoveAllSources(bool b
 }
 
 
-void CPartFile::Delete()
+void CPartFile::Delete(bool setAsCancelled)
 {
 	AddLogLineM(false, CFormat(_("Deleting file: %s")) % GetFileName());
 	// Barry - Need to tell any connected clients to stop sending the file
@@ -2419,6 +2419,11 @@ void CPartFile::Delete()
 		}
 	}
 
+	if (setAsCancelled) {
+		theApp->knownfiles->SafeAddCancelledFile(this);
+		AddDebugLogLineM(false, logPartFile, wxT("\tAdded to cancelled file list"));
+	}
+	
 	AddDebugLogLineM(false, logPartFile, wxT("Done"));
 	
 	delete this;
--- src.org/PartFile.h
+++ src/PartFile.h
@@ -184,7 +184,7 @@ public:
 
 	void	RemoveBlockFromList(uint64 start,uint64 end);
 	void	RemoveAllSources(bool bTryToSwap);
-	void	Delete();
+	void	Delete(bool setAsCancelled);
 	void	Rehash();
 	void	ForceCompletion();
 	void	StopFile(bool bCancel = false);
--- src.org/SearchListCtrl.cpp
+++ src/SearchListCtrl.cpp
@@ -294,6 +294,11 @@ void CSearchListCtrl::UpdateItemColor( l
 				green = 128;
 				blue = 128;
 			}
+		} else if (theApp->knownfiles->FindCancelledFileByID(file->GetFileHash())) {
+			// File has been cancelled. Mark as orange.
+			red = 255;
+			green = 170;
+			blue = 0;
 		} else {
 			// File is new, colour after number of files
 			blue += file->GetSourceCount() * 5;
