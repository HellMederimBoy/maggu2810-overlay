--- src.org/DownloadListCtrl.cpp
+++ src/DownloadListCtrl.cpp
@@ -124,6 +124,8 @@ BEGIN_EVENT_TABLE(CDownloadListCtrl, CMu
 	EVT_CHAR( CDownloadListCtrl::OnKeyPressed )
 
 	EVT_MENU( MP_CANCEL, 			CDownloadListCtrl::OnCancelFile )
+	EVT_MENU( MP_REHASH,			CDownloadListCtrl::OnRehashFile )
+	EVT_MENU( MP_FORCECOMPL,		CDownloadListCtrl::OnForceCompletion )
 	
 	EVT_MENU( MP_PAUSE,			CDownloadListCtrl::OnSetStatus )
 	EVT_MENU( MP_STOP,			CDownloadListCtrl::OnSetStatus )
@@ -607,6 +609,52 @@ void CDownloadListCtrl::OnCancelFile(wxC
 }
 
 
+void CDownloadListCtrl::OnRehashFile(wxCommandEvent& WXUNUSED(event))
+{
+	ItemList files = ::GetSelectedItems(this, itFILES);
+	for (ItemList::iterator it = files.begin(); it != files.end(); ++it) {
+		CPartFile* file = (*it)->GetFile();
+		if (file) {
+			switch (file->GetStatus()) {
+			case PS_WAITINGFORHASH:
+			case PS_HASHING:
+			case PS_COMPLETING:
+			case PS_COMPLETE:
+				break;
+			default:
+				CoreNotify_PartFile_Rehash(file);
+			}
+		}
+	}
+}
+
+
+void CDownloadListCtrl::OnForceCompletion(wxCommandEvent& WXUNUSED(event))
+{
+	ItemList files = ::GetSelectedItems(this, itFILES);
+	if (files.size()) {	
+		wxString question = 
+			_("Are you sure that you wish to force completion of the selected file(s)?");	
+		if (wxMessageBox( question, _("Cancel"), wxICON_QUESTION | wxYES_NO, this) == wxYES) {
+			for (ItemList::iterator it = files.begin(); it != files.end(); ++it) {
+				CPartFile* file = (*it)->GetFile();
+				if (file) {
+					switch (file->GetStatus()) {
+					case PS_WAITINGFORHASH:
+					case PS_HASHING:
+					case PS_COMPLETING:
+					case PS_COMPLETE:
+						break;
+					default:
+						CoreNotify_PartFile_ForceCompletion(file);
+					}
+				}
+			}
+		}
+	}
+}
+
+
 void CDownloadListCtrl::OnSetPriority( wxCommandEvent& event )
 {
 	int priority = 0;
@@ -921,6 +969,8 @@ void CDownloadListCtrl::OnMouseRightClic
 
 		m_menu->Append(MP_MENU_PRIO, _("Priority"), priomenu);
 		m_menu->Append(MP_CANCEL, _("Cancel"));
+		m_menu->Append(MP_REHASH, _("Rehash"));
+		m_menu->Append(MP_FORCECOMPL, _("Complete"));
 		m_menu->Append(MP_STOP, _("&Stop"));
 		m_menu->Append(MP_PAUSE, _("&Pause"));
 		m_menu->Append(MP_RESUME, _("&Resume"));
--- src.org/DownloadListCtrl.h
+++ src/DownloadListCtrl.h
@@ -217,6 +217,8 @@ private:
 
 	// Event-handlers for files
 	void	OnCancelFile( wxCommandEvent& event );
+	void	OnRehashFile( wxCommandEvent& event );
+	void	OnForceCompletion( wxCommandEvent& event );
 	void	OnSetPriority( wxCommandEvent& event );
 	void	OnSwapSources( wxCommandEvent& event );
 	void	OnSetCategory( wxCommandEvent& event );	
--- src.org/ExternalConn.cpp
+++ src/ExternalConn.cpp
@@ -551,6 +551,14 @@ CECPacket *Get_EC_Response_PartFile_Cmd(
 				pfile->Delete();
 				break;
 
+			case EC_OP_PARTFILE_REHASH:
+				pfile->Rehash();
+				break;
+
+			case EC_OP_PARTFILE_FORCECOMPL:
+				pfile->ForceCompletion();
+				break;
+
 			case EC_OP_PARTFILE_SET_CAT:
 				pfile->SetCategory(hashtag->GetTagByIndexSafe(0)->GetInt());
 				break;
@@ -1069,6 +1077,8 @@ CECPacket *ExternalConn::ProcessRequest2
 		case EC_OP_PARTFILE_STOP:
 		case EC_OP_PARTFILE_PRIO_SET:
 		case EC_OP_PARTFILE_DELETE:
+		case EC_OP_PARTFILE_REHASH:
+		case EC_OP_PARTFILE_FORCECOMPL:
 		case EC_OP_PARTFILE_SET_CAT:
 			response = Get_EC_Response_PartFile_Cmd(request);
 			break;
--- src.org/GuiEvents.cpp
+++ src/GuiEvents.cpp
@@ -125,6 +125,16 @@ namespace MuleNotify
 		theApp->downloadqueue->SendFileCommand(file, EC_OP_PARTFILE_DELETE);
 	}
 	
+	void PartFile_Rehash(CPartFile* file)
+	{
+		theApp->downloadqueue->SendFileCommand(file, EC_OP_PARTFILE_REHASH);
+	}
+	
+	void PartFile_ForceCompletion(CPartFile* file)
+	{
+		theApp->downloadqueue->SendFileCommand(file, EC_OP_PARTFILE_FORCECOMPL);
+	}
+	
 	void PartFile_SetCat(CPartFile* file, uint32 val)
 	{
 		theApp->downloadqueue->Category(file, val);
@@ -586,6 +596,16 @@ namespace MuleNotify
 		file->Delete();
 	}
 	
+	void PartFile_Rehash(CPartFile* file)
+	{
+		file->Rehash();
+	}
+	
+	void PartFile_ForceCompletion(CPartFile* file)
+	{
+		file->ForceCompletion();
+	}
+	
 	void PartFile_SetCat(CPartFile* file, uint32 val)
 	{
 		file->SetCategory(val);
--- src.org/GuiEvents.h
+++ src/GuiEvents.h
@@ -120,6 +120,8 @@ namespace MuleNotify
 	void PartFile_PrioAuto(CPartFile* file, bool val);
 	void PartFile_PrioSet(CPartFile* file, uint8 newDownPriority, bool bSave);
 	void PartFile_Delete(CPartFile* file);
+	void PartFile_Rehash(CPartFile* file);
+	void PartFile_ForceCompletion(CPartFile* file);
 	void PartFile_SetCat(CPartFile* file, uint32 val);
 
 	void KnownFile_Up_Prio_Set(CKnownFile* file, uint8 val);
@@ -450,6 +452,8 @@ typedef void (wxEvtHandler::*MuleNotifyE
 #define CoreNotify_PartFile_PrioAuto(ptr, val)		MuleNotify::DoNotify(&MuleNotify::PartFile_PrioAuto, ptr, val)
 #define CoreNotify_PartFile_PrioSet(p, v0, v1)		MuleNotify::DoNotify(&MuleNotify::PartFile_PrioSet, p, v0, v1)
 #define CoreNotify_PartFile_Delete(ptr)			MuleNotify::DoNotify(&MuleNotify::PartFile_Delete, ptr)
+#define CoreNotify_PartFile_Rehash(ptr)			MuleNotify::DoNotify(&MuleNotify::PartFile_Rehash, ptr)
+#define CoreNotify_PartFile_ForceCompletion(ptr)	MuleNotify::DoNotify(&MuleNotify::PartFile_ForceCompletion, ptr)
 #define CoreNotify_PartFile_SetCat(ptr, val)		MuleNotify::DoNotify(&MuleNotify::PartFile_SetCat, ptr, val)
 
 // KnownFile
--- src.org/include/common/MenuIDs.h
+++ src/include/common/MenuIDs.h
@@ -80,6 +80,8 @@ enum {
 	MP_CLOSE_ALL_TABS,
 	MP_CLOSE_OTHER_TABS,
 	MP_RENAME,
+	MP_REHASH,
+	MP_FORCECOMPL,
 
 /* Razor 1a - Modif by MikaelB
      Opcodes for :
--- src.org/libs/ec/abstracts/ECCodes.abstract
+++ src/libs/ec/abstracts/ECCodes.abstract
@@ -73,6 +73,8 @@ EC_OP_PARTFILE_RESUME               0x1A
 EC_OP_PARTFILE_STOP                 0x1B
 EC_OP_PARTFILE_PRIO_SET             0x1C
 EC_OP_PARTFILE_DELETE               0x1D
+EC_OP_PARTFILE_REHASH               0x60
+EC_OP_PARTFILE_FORCECOMPL           0x61
 EC_OP_PARTFILE_SET_CAT              0x1E
 
 EC_OP_DLOAD_QUEUE                   0x1F
--- src.org/libs/ec/c#/ECCodes.cs
+++ src/libs/ec/c#/ECCodes.cs
@@ -66,6 +66,8 @@ public enum ECOpCodes {
 	EC_OP_PARTFILE_STOP                 = 0x1B,
 	EC_OP_PARTFILE_PRIO_SET             = 0x1C,
 	EC_OP_PARTFILE_DELETE               = 0x1D,
+	EC_OP_PARTFILE_REHASH               = 0x60,
+	EC_OP_PARTFILE_FORCECOMPL           = 0x61,
 	EC_OP_PARTFILE_SET_CAT              = 0x1E,
 	EC_OP_DLOAD_QUEUE                   = 0x1F,
 	EC_OP_ULOAD_QUEUE                   = 0x20,
--- src.org/libs/ec/cpp/ECCodes.h
+++ src/libs/ec/cpp/ECCodes.h
@@ -74,6 +74,8 @@ enum ECOpCodes {
 	EC_OP_PARTFILE_STOP                 = 0x1B,
 	EC_OP_PARTFILE_PRIO_SET             = 0x1C,
 	EC_OP_PARTFILE_DELETE               = 0x1D,
+	EC_OP_PARTFILE_REHASH               = 0x60,
+	EC_OP_PARTFILE_FORCECOMPL           = 0x61,
 	EC_OP_PARTFILE_SET_CAT              = 0x1E,
 	EC_OP_DLOAD_QUEUE                   = 0x1F,
 	EC_OP_ULOAD_QUEUE                   = 0x20,
--- src.org/libs/ec/java/ECCodes.java
+++ src/libs/ec/java/ECCodes.java
@@ -64,6 +64,8 @@ public final static byte EC_OP_PARTFILE_
 public final static byte EC_OP_PARTFILE_STOP                 = 0x1B;
 public final static byte EC_OP_PARTFILE_PRIO_SET             = 0x1C;
 public final static byte EC_OP_PARTFILE_DELETE               = 0x1D;
+public final static byte EC_OP_PARTFILE_REHASH               = 0x60;
+public final static byte EC_OP_PARTFILE_FORCECOMPL           = 0x61;
 public final static byte EC_OP_PARTFILE_SET_CAT              = 0x1E;
 public final static byte EC_OP_DLOAD_QUEUE                   = 0x1F;
 public final static byte EC_OP_ULOAD_QUEUE                   = 0x20;
--- src.org/PartFile.cpp
+++ src/PartFile.cpp
@@ -2205,6 +2205,22 @@ void CPartFile::RemoveAllRequestedBlocks
 }
 
 
+void CPartFile::Rehash()
+{
+	// must not be PS_COMPLETING !!!
+	SetPartFileStatus(PS_WAITINGFORHASH);
+
+	wxString strPartFile = m_partmetfilename.Left( m_partmetfilename.Length() - 4 );
+	CThreadScheduler::AddTask(new CHashingTask(GetFilePath(), strPartFile, this));
+}
+
+
+void CPartFile::ForceCompletion()
+{
+	CompleteFile(true);
+}
+
+
 void CPartFile::CompleteFile(bool bIsHashingDone)
 {
 	if (GetKadFileSearchID()) {
--- src.org/PartFile.h
+++ src/PartFile.h
@@ -166,6 +166,8 @@ public:
 	void	RemoveBlockFromList(uint64 start,uint64 end);
 	void	RemoveAllSources(bool bTryToSwap);
 	void	Delete();
+	void	Rehash();
+	void	ForceCompletion();
 	void	StopFile(bool bCancel = false);
 	void	PauseFile(bool bInsufficient = false);
 	void	ResumeFile();
--- src.org/TextClient.cpp
+++ src/TextClient.cpp
@@ -62,6 +62,8 @@ enum {
 	CMD_ID_PRIORITY_HIGH,
 	CMD_ID_PRIORITY_AUTO,
 	CMD_ID_CANCEL,
+	CMD_ID_REHASH,
+	CMD_ID_FORCECOMPL,
 	CMD_ID_CONNECT,
 	CMD_ID_CONNECT_ED2K,
 	CMD_ID_CONNECT_KAD,
@@ -297,6 +299,8 @@ int CamulecmdApp::ProcessCommand(int Cmd
 
 		case CMD_ID_PAUSE:
 		case CMD_ID_CANCEL:
+		case CMD_ID_REHASH:
+		case CMD_ID_FORCECOMPL:
 		case CMD_ID_RESUME:
 			if ( args.IsEmpty() ) {
 				Show(_("This command requieres an argument. Valid arguments: 'all' or a number.\n"));
@@ -310,6 +314,10 @@ int CamulecmdApp::ProcessCommand(int Cmd
 							request = new CECPacket(EC_OP_PARTFILE_PAUSE); break;
 						case CMD_ID_CANCEL:
 							request = new CECPacket(EC_OP_PARTFILE_DELETE); break;
+						case CMD_ID_REHASH:
+							request = new CECPacket(EC_OP_PARTFILE_REHASH); break;
+						case CMD_ID_FORCECOMPL:
+							request = new CECPacket(EC_OP_PARTFILE_FORCECOMPL); break;
 						case CMD_ID_RESUME:
 							request = new CECPacket(EC_OP_PARTFILE_RESUME); break;
 						default: wxASSERT(0);
@@ -333,6 +341,10 @@ int CamulecmdApp::ProcessCommand(int Cmd
 								request = new CECPacket(EC_OP_PARTFILE_PAUSE); break;
 							case CMD_ID_CANCEL:
 								request = new CECPacket(EC_OP_PARTFILE_DELETE); break;
+							case CMD_ID_REHASH:
+								request = new CECPacket(EC_OP_PARTFILE_REHASH); break;
+							case CMD_ID_FORCECOMPL:
+								request = new CECPacket(EC_OP_PARTFILE_FORCECOMPL); break;
 							case CMD_ID_RESUME:
 								request = new CECPacket(EC_OP_PARTFILE_RESUME); break;
 							default: wxASSERT(0);
@@ -922,6 +934,12 @@ void CamulecmdApp::OnInitCommandSet()
    	m_commands.AddCommand(wxT("Cancel"), CMD_ID_CANCEL, wxTRANSLATE("Cancel download."),
   			      wxEmptyString, CMD_PARAM_ALWAYS);
 
+  	m_commands.AddCommand(wxT("Rehash"), CMD_ID_REHASH, wxTRANSLATE("Rehash download."),
+ 			      wxEmptyString, CMD_PARAM_ALWAYS);
+
+  	m_commands.AddCommand(wxT("ForceCompl"), CMD_ID_FORCECOMPL, wxTRANSLATE("Force completion of an incomplete download."),
+ 			      wxEmptyString, CMD_PARAM_ALWAYS);
+
 	tmp = m_commands.AddCommand(wxT("Priority"), CMD_ERR_INCOMPLETE, wxTRANSLATE("Set download priority."),
 				    wxTRANSLATE("Set priority of a download to Low, Normal, High or Auto.\n"), CMD_PARAM_ALWAYS);
 	tmp->AddCommand(wxT("Low"), CMD_ID_PRIORITY_LOW, wxTRANSLATE("Set priority to low."), wxEmptyString, CMD_PARAM_ALWAYS);
